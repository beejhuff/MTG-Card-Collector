"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const request = require("request-promise");
__export(require("./IScry"));
const endpoint = "https://api.scryfall.com";
const rateLimit = 100;
let lastQuery = 0;
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
function queryApi(apiPath, query) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Array.isArray(apiPath))
            apiPath = apiPath.join("/");
        const now = Date.now();
        const timeSinceLastQuery = now - lastQuery;
        if (timeSinceLastQuery >= rateLimit) {
            lastQuery = now;
        }
        else {
            const timeUntilNextQuery = rateLimit - timeSinceLastQuery;
            lastQuery += timeUntilNextQuery;
            yield sleep(timeUntilNextQuery);
        }
        return request({
            uri: `${endpoint}/${apiPath}`,
            json: true,
            qs: query,
        });
    });
}
class MagicEmitter extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this._cancelled = false;
    }
    get cancelled() {
        return this._cancelled;
    }
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    emit(event, ...data) {
        return super.emit(event, ...data);
    }
    cancel() {
        this._cancelled = true;
        this.emit("cancel");
    }
    waitForAll() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const results = [];
                this.on("data", (result) => {
                    results.push(result);
                });
                this.on("end", () => resolve(results));
            });
        });
    }
}
exports.MagicEmitter = MagicEmitter;
var Cards;
(function (Cards) {
    function byName(name, fuzzy = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return queryApi("cards/named", {
                [fuzzy ? "fuzzy" : "exact"]: name,
            });
        });
    }
    Cards.byName = byName;
    function byId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return queryApi(["cards", id]);
        });
    }
    Cards.byId = byId;
    function bySet(setCode, collectorNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            return queryApi(["cards", setCode, collectorNumber]);
        });
    }
    Cards.bySet = bySet;
    function byMultiverseId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return queryApi(["cards/multiverse", id]);
        });
    }
    Cards.byMultiverseId = byMultiverseId;
    function byMtgoId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return queryApi(["cards/mtgo", id]);
        });
    }
    Cards.byMtgoId = byMtgoId;
    function random() {
        return __awaiter(this, void 0, void 0, function* () {
            return queryApi("cards/random");
        });
    }
    Cards.random = random;
    function getPage(emitter, apiPath, query, page = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield queryApi(apiPath, Object.assign({}, query, { page }));
            for (const card of results.data) {
                emitter.emit("data", card);
            }
            if (results.has_more) {
                if (!emitter.cancelled)
                    getPage(emitter, apiPath, query, page + 1).catch(err => emitter.emit("error", err));
            }
            else {
                emitter.emit("end");
            }
        });
    }
    function search(search) {
        const emitter = new MagicEmitter();
        getPage(emitter, "cards/search", { q: search }).catch(err => emitter.emit("error", err));
        return emitter;
    }
    Cards.search = search;
    function all() {
        const emitter = new MagicEmitter();
        getPage(emitter, "cards", {}).catch(err => emitter.emit("error", err));
        return emitter;
    }
    Cards.all = all;
    function autoCompleteName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("cards/autocomplete", { q: name })).data;
        });
    }
    Cards.autoCompleteName = autoCompleteName;
})(Cards = exports.Cards || (exports.Cards = {}));
var Sets;
(function (Sets) {
    function all() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("sets")).data;
        });
    }
    Sets.all = all;
    function byCode(code) {
        return __awaiter(this, void 0, void 0, function* () {
            return queryApi(["sets", code]);
        });
    }
    Sets.byCode = byCode;
})(Sets = exports.Sets || (exports.Sets = {}));
var Symbology;
(function (Symbology) {
    function all() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("symbology")).data;
        });
    }
    Symbology.all = all;
    function parseMana(shorthand) {
        return __awaiter(this, void 0, void 0, function* () {
            return queryApi("symbology/parse-mana", { cost: shorthand });
        });
    }
    Symbology.parseMana = parseMana;
})(Symbology = exports.Symbology || (exports.Symbology = {}));
var Catalog;
(function (Catalog) {
    function cardNames() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/card-names")).data;
        });
    }
    Catalog.cardNames = cardNames;
    function wordBank() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/word-bank")).data;
        });
    }
    Catalog.wordBank = wordBank;
    function creatureTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/creature-types")).data;
        });
    }
    Catalog.creatureTypes = creatureTypes;
    function planeswalkerTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/planeswalker-types")).data;
        });
    }
    Catalog.planeswalkerTypes = planeswalkerTypes;
    function landTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/land-types")).data;
        });
    }
    Catalog.landTypes = landTypes;
    function artifactTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/artifact-types")).data;
        });
    }
    Catalog.artifactTypes = artifactTypes;
    function enchantmentTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/enchantment-types")).data;
        });
    }
    Catalog.enchantmentTypes = enchantmentTypes;
    function spellTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/spell-types")).data;
        });
    }
    Catalog.spellTypes = spellTypes;
    function powers() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/powers")).data;
        });
    }
    Catalog.powers = powers;
    function toughnesses() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/toughnesses")).data;
        });
    }
    Catalog.toughnesses = toughnesses;
    function loyalties() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/loyalties")).data;
        });
    }
    Catalog.loyalties = loyalties;
    function watermarks() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi("catalog/watermarks")).data;
        });
    }
    Catalog.watermarks = watermarks;
})(Catalog = exports.Catalog || (exports.Catalog = {}));
function homepageLinks() {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield queryApi("homepage-links")).data;
    });
}
exports.homepageLinks = homepageLinks;
var Rulings;
(function (Rulings) {
    function byId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi(["cards", id, "rulings"])).data;
        });
    }
    Rulings.byId = byId;
    function bySet(setCode, collectorNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi(["cards", setCode, collectorNumber, "rulings"])).data;
        });
    }
    Rulings.bySet = bySet;
    function byMultiverseId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi(["cards/multiverse", id, "rulings"])).data;
        });
    }
    Rulings.byMultiverseId = byMultiverseId;
    function byMtgoId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield queryApi(["cards/mtgo", id, "rulings"])).data;
        });
    }
    Rulings.byMtgoId = byMtgoId;
})(Rulings = exports.Rulings || (exports.Rulings = {}));
